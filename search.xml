<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap头插法多线程形成环，导致死循环</title>
    <url>/2021/08/28/HashMap%E5%A4%B4%E6%8F%92%E6%B3%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BD%A2%E6%88%90%E7%8E%AF%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li>在 jdk 1.7 及以前HashMap使用头插法，多线程的情况下容易形成环。</li>
</ul>
<p>假设在下标为1处有一个长度为2的链表，如果再次插入一个节点，就需要resize()扩容。 </p>
<p><img src="/images/pasted-1.png" alt="HasMap"></p>
<p>此时两个线程A和B执行put()操作，A线程先执行，执行完transfer () 中的<code>Entry&lt;K,V&gt; next = e.next;</code>被挂起，此时e指针指向5，next指向7，如图所示。</p>
<p><img src="/images/pasted-2.png" alt="线程A执行"></p>
<p>此时线程B执行，将数组扩大两倍，链表仍散列在下标为1处，由于使用了头插法，节点位置将会交换，如图所示。</p>
<p><img src="/images/pasted-3.png" alt="线程B执行"></p>
<p>这时候线程A又执行，因为原先e指向5，next执行7，继续执行下一条语句<code>e.next = newTable[i];</code>，这时会出现5指向7的情况，如图所示。</p>
<p><img src="/images/pasted-4.png" alt="链表形成"></p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>那么在get取值的时候，由于环的存在，，就会不停止地寻找节点值，导致死循环。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <url>/2021/08/24/Ch2-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图2-1所示。<br><img src="/images/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="图2-1 Java虚拟机运行时数据区" title="图2-1 Java虚拟机运行时数据区"></p>
<h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h3><ul>
<li>程序计数器(Program Counter Register)是一块较小的内存空间，他可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条指令中的指令。因此，为了线程切换后能恢复到正确的位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有”的内存。</li>
<li>如果程序正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域。</li>
</ul>
<h3 id="2-2-2-Java虚拟机栈"><a href="#2-2-2-Java虚拟机栈" class="headerlink" title="2.2.2 Java虚拟机栈"></a>2.2.2 Java虚拟机栈</h3><ul>
<li>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个战争用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型（指向了一条字节码指令的地址）</li>
<li>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。</li>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</li>
</ul>
<h3 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3 本地方法栈"></a>2.2.3 本地方法栈</h3><ul>
<li>本地方法栈与虚拟机栈所发挥的作用很相似，区别在于虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地方法服务。</li>
</ul>
<h3 id="2-2-4-Java堆"><a href="#2-2-4-Java堆" class="headerlink" title="2.2.4 Java堆"></a>2.2.4 Java堆</h3><ul>
<li>几乎所有的对象实例以及数组都应当在堆上分配。</li>
<li>垃圾收集器管理的主要区域。</li>
<li>从分配内存的角度，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Theard Local Allocation Buffer, TLAB），以提升效率。</li>
<li>Java堆可以实现成固定大小的，也可以是可扩展的，主流的Java虚拟机都是可扩展的（通过参数最大值：-Xmx和最小值：-Xms设定），Java堆没有内存分配实例对象，并且无法扩展时，将会抛出OutOfMemoryError异常。</li>
</ul>
<h3 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5 方法区"></a>2.2.5 方法区</h3><ul>
<li>和Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据。<ul>
<li>类信息：即 Class 类，如类名、访问修饰符、常量池、字段描述、方法描述等。</li>
</ul>
</li>
<li>关于“永久代”（Permanent Generation）这个概念：由于HotSpot虚拟机使用“永久代”来实现方法区，故许多Java程序员都习惯把方法区称呼为“永久代”，但这种设计更容易导致内存溢出问题。在JDK6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区，到了JDK7，已经把原本放在永久代的字符串常量池、静态变量等移除，而到了JDK8，终于完全废弃了永久代的概念，改用了与JPockit、J9一样在本地内存中实现的元空间中 。</li>
<li>垃圾收集行为比较少，甚至可以不实现垃圾收集。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</li>
<li>无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</li>
</ul>
<h3 id="2-2-6-运行时常量池"><a href="#2-2-6-运行时常量池" class="headerlink" title="2.2.6 运行时常量池"></a>2.2.6 运行时常量池</h3><ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区。</li>
</ul>
<h3 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7 直接内存"></a>2.2.7 直接内存</h3><ul>
<li>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，但被频繁地使用，而且也可能导致OutOfMemoryError异常。</li>
<li>在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li>
<li>一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</li>
</ul>
<h2 id="2-3-HotSpot-虚拟机堆中的对象"><a href="#2-3-HotSpot-虚拟机堆中的对象" class="headerlink" title="2.3 HotSpot 虚拟机堆中的对象"></a>2.3 HotSpot 虚拟机堆中的对象</h2><p>这一小节将对 JVM 对 Java 堆中的对象的创建、布局和访问的全过程进行讲解。</p>
<h3 id="2-3-1对象的创建"><a href="#2-3-1对象的创建" class="headerlink" title="2.3.1对象的创建"></a>2.3.1对象的创建</h3><p>遇到一条New指令，虚拟机的步骤：</p>
<ol>
<li>检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先把这个类加载进内存；</li>
<li>类加载检查通过后，虚拟机将为新对象分配内存，类加载完就可以确定存储这个对象所需的内存大小；</li>
<li>将分配到的内存空间初始化为零值；</li>
<li>设置对象头（Object Header）中的数据，包括这个对象是哪个类的实例、如何才能找到类的元数据、对象的哈希码（实际在调用Object::hashCode()方法才计算）、对象的GC分代年龄等；</li>
<li>此时从虚拟机的角度看，对象已经产生，但从 Java 程序的角度看，构造函数还没有执行。执行完初始化函数，一个真正的对象才算完全构造出来。</li>
</ol>
<p>在第二步中，为对象分配内存，就是在内存划分一块确定大小的空闲内存，但存在两个问题：</p>
<ol>
<li><p>如何划分空闲内存和已被使用的内存？</p>
<ul>
<li>假设Java堆中内存是绝对规整的，空闲内存和被使用内存被分到两边，中间放置指针作为分界点的指示器，那分配内存就是把指针向空闲内存一定一段，这种方式成为“指针碰撞（Bump The Pointer）”。</li>
<li>但如果Java堆内存不是规整的，那就没有办法简单地进行指针碰撞了，虚拟机需要维护一个列表，记录哪些内存块可以使用，在分配内存的时候，找到一块足够打的内存划分给对象实例，并更新列表上的记录，这种方式被称为“空闲列表（Free List）”。</li>
<li>事实上，这由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Seria、parNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上只能采用较为复杂的空闲列表来分配内存。</li>
</ul>
</li>
<li><p>如何处理多线程下，内存分配问题？</p>
<ul>
<li>对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Theard Local Allocation Buffer, TLAB）,哪个线程要分配内存就先在本地线程分配缓冲中分配，只有缓冲使用完了，分配新的缓存区时需要同步锁定。</li>
<li>通过-XX:+/-UseTLAB 参数设置是否使用TLAB。</li>
</ul>
</li>
</ol>
<h3 id="2-3-2对象的内存布局"><a href="#2-3-2对象的内存布局" class="headerlink" title="2.3.2对象的内存布局"></a>2.3.2对象的内存布局</h3><ul>
<li><p>对象头（Header）：</p>
<ul>
<li>第一部分：存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。（官方称之为“Mark Word”）。</li>
<li>第二部分：类型指针，即对象指向它的类型元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例，如果是数组对象，将会在对象头存储数组长度，以确定对象大小。</li>
</ul>
</li>
<li><p>实例数据（Instance Data）：</p>
<ul>
<li>在程序代码里面所有定义的各种类型的字段内容都必须记录。</li>
<li>这部分的存储顺序受到虚拟机分配策略参数（-XX:FieldsAllocationStyle 参数）和Java源码中定义顺序的影响。</li>
<li>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers, OOPs)，相同宽度的字段总是被分配到一起存放，满足这个条件的前提下，父类定义的变量会出现在子类之前。</li>
</ul>
</li>
<li><p>对齐填充（Padding）：</p>
</li>
</ul>
<h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3 对象的访问定位"></a>2.3.3 对象的访问定位</h3><p>Java程序通过栈上的reference数据来操作堆上具体对象，主流的访问方式主要有以下两种：</p>
<ul>
<li>使用句柄：Java堆可能会划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自Juin的地址信息。结构如图2-2所示。</li>
<li>优势：在对象被移动（垃圾收集时移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而不需修改reference。</li>
</ul>
<p><img src="/images/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png"></p>
<ul>
<li>使用直接指针：Java堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身，就不需要多一次间接访问的开销。如图2-3所示。</li>
<li>优势：速度快，节省一次指针定位的时间开销。<img src="/images/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png"></li>
</ul>
<h2 id="2-4-实战：-OutOfMemoryError异常"><a href="#2-4-实战：-OutOfMemoryError异常" class="headerlink" title="2.4 实战： OutOfMemoryError异常"></a>2.4 实战： OutOfMemoryError异常</h2><h3 id="2-4-1-Java堆溢出"><a href="#2-4-1-Java堆溢出" class="headerlink" title="2.4.1 Java堆溢出"></a>2.4.1 Java堆溢出</h3><ul>
<li>Java堆内存的OutOfMemoryError异常是实际应用最常见的内存溢出情况，异常堆栈信息“java.lang.OutOfMemoryError”会进一步提示“Java heap space”。</li>
<li>解决方法：<ul>
<li>首先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。分析清楚是出现内存泄漏（Memory Leak）还是内存溢出（Memory overflow），即导致OOM的对象是否是必要的。</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们。根据泄漏对象的类型信息以及它到GC Roots 引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找到产生内存泄漏的代码具体位置。</li>
<li>如果是内存溢出，检查Java虚拟机的堆参数（-Xmx与-Xms）设置，检查代码对象生命周期是否过长、存储结构设计不合理等情况，减少程序运行的内存消耗。</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-虚拟机栈和本地方法栈溢出"><a href="#2-4-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.4.2 虚拟机栈和本地方法栈溢出"></a>2.4.2 虚拟机栈和本地方法栈溢出</h3><ul>
<li>线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机栈允许动态扩展，当扩展栈容量无法申请到足够的内存，将抛出OutOfMemoryError异常。</li>
</ul>
<h3 id="2-4-3方法区和运行时常量池溢出"><a href="#2-4-3方法区和运行时常量池溢出" class="headerlink" title="2.4.3方法区和运行时常量池溢出"></a>2.4.3方法区和运行时常量池溢出</h3><ul>
<li>运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是“PermGen space”。</li>
<li>类加载过多，会导致方法区内存溢出，在实际的应用中，如Spring框架，会使用到CGLib这类字节码技术，会产生大量的动态类，容易导致内存溢出，需要注意垃圾回收；除此之外常见的还有大量JSP或动态JSP文件应用、基于OSGi的应用等。</li>
<li>在JDK8后，永久代完全退出，元空间作为替代者登场。在默认设置下，动态创建新类型已经很难使虚拟机出现产生方法区内存溢出。</li>
</ul>
<h3 id="2-4-4本机直接内存溢出"><a href="#2-4-4本机直接内存溢出" class="headerlink" title="2.4.4本机直接内存溢出"></a>2.4.4本机直接内存溢出</h3><ul>
<li><code>--XX:MaxDirectMemorySize</code>设置，如不指定，默认与Java堆最大值（-Xmx指定）一致。</li>
<li>出现的明显特征，Heap Dump文件不会看见明显的异常情况，如发现内存溢出后产生的Dump文件很小，而程序又直接或间接使用了DirectMemory（典型的间接使用是NIO），那可以考虑重点检查直接内存的问题。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Redis-字典（hash表的底层实现）</title>
    <url>/2021/01/10/Redis-%E5%AD%97%E5%85%B8%EF%BC%88hash%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<p>字典，又称为符号表、关联数组或映射，是一种保存键值对的抽象数据结构。字典中每个键都是独一无二的，可以根据键对键值对进行操作。Redis所使用的C语言并没有内置字典，因此Redis构建了自己的字典实现。<br>Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在对字典的操作之上的。</p>
<p>例如，SET msg “hello world”，这个键值对就是保存在代表数据库字典里面的。</p>
<p>除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p>
<h1 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h1><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点只能保存一个键值对。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组，每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小，table 数组的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下图是一个空的哈希表<br><img src="/images/hash%E8%A1%A8.png" alt="hash表"></p>
<h2 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h2><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表，用解决hash冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>下图是将两个索引值相同的键k1和k0连接在一起。<br><img src="/images/hash%E8%A1%A8%E5%8A%A0%E8%8A%82%E7%82%B9.png" alt="Hash表加节点"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Redis 中的字典由 dict.h/dict 结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<ul>
<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<ul>
<li>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</li>
<li>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。<br>一个普通状态下（没有进行 rehash）的字典：<br><img src="/images/%E5%AD%97%E5%85%B8.png" alt="字典"></li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式（如何使用Lambda进行排序）</title>
    <url>/2021/04/04/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Lambda%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Lambda表达式简介"><a href="#Lambda表达式简介" class="headerlink" title="Lambda表达式简介"></a>Lambda表达式简介</h1><ul>
<li>Lambda表达式也被称为箭头函数、匿名函数、闭包。箭头为操作符。</li>
<li>Lambda表达式体现的是轻量级函数编程思想。Model Code as Data，编码及数据尽可能轻量级的将代码封装为数据。通常的解决方式是通过接口和实现类来实现，这样存在语法冗余、this关键字、变量捕获的问题。</li>
<li>Lambda表达式是JDK8的一个新特性，可以代替匿名内部类写出优雅的Java代码。<h1 id="函数式接口的理解"><a href="#函数式接口的理解" class="headerlink" title="函数式接口的理解"></a>函数式接口的理解</h1></li>
<li>被@FunctionalInterface注解的接口都是函数式接口。函数式接口只包含一个需要被实现的方法（默认方法和静态方法不在其中）。Lambda表达式是针对函数式接口的语法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//只包含一个需要被实现的方法的函数式接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface ReturnOneParam&#123;</span><br><span class="line">    String method(String username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//包含一个被default修饰的方法，默认实现，不是必须被实现的方法</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface ReturnOneParam&#123;</span><br><span class="line">    String method(String username);</span><br><span class="line">    default String method2(String username)&#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    //继承自Object的方法也不会影响函数式接口的语法</span><br><span class="line">    @Override</span><br><span class="line">    String toString();</span><br><span class="line">&#125;</span><br><span class="line">//具有两个参数</span><br><span class="line">@FunctionalInterface</span><br><span class="line"> interface ReturnTwoParam&#123;</span><br><span class="line">     String method(String username, Integer age);</span><br><span class="line"> &#125;</span><br><span class="line">//如果想要实现上面的接口，可以使用匿名内部类来实现，也可使用Lambda表达式来实现</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     //括号里面为参数，要与接口中的参数类型和数量一致，-&gt; 表示操作符，大括号中的为</span><br><span class="line">     //实现的语句体，如果方法需要返回值，可以使用return返回。</span><br><span class="line">     ReturnOneParam returnOneParam = (String username) -&gt; &#123;</span><br><span class="line">       return username + &quot; 你好&quot;;  </span><br><span class="line">     &#125;;</span><br><span class="line">     //打印出`Tom 你好`</span><br><span class="line">     System.out.println(returnOneParam.method(&quot;Tom&quot;));</span><br><span class="line">     </span><br><span class="line">     //如果参数只有一个可以不用写括号，多个参数时必须将参数括起来</span><br><span class="line">     //可以不用写参数类型，jvm自动解析</span><br><span class="line">     //如果方法体中只有一行代码，并且需要返回值，可以省略return关键字</span><br><span class="line">     ReturnOneParam returnOneParam1 = username -&gt; username + &quot; 你好&quot;;</span><br><span class="line">     System.out.println(returnOneParam1.method(&quot;Jerry&quot;));</span><br><span class="line">     </span><br><span class="line">     //两个参数，有返回值且只有一行代码。</span><br><span class="line">     ReturnTwoParam returnTwoParam = (username , age) -&gt; username + &quot;今年&quot;+  age + &quot;岁&quot;;</span><br><span class="line">     //打印“小红今年19岁”</span><br><span class="line">     returnTwoParam.method(&quot;小红&quot;, 19);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内置函数式接口"><a href="#内置函数式接口" class="headerlink" title="内置函数式接口"></a>内置函数式接口</h1><ul>
<li><p>java.util.function.Predicate<T>，接收参数T，返回boolean类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断传来的对象是不是Tom</span><br><span class="line">Predicate predicate = e -&gt; “Tom”.equals(e);</span><br><span class="line">//打印false</span><br><span class="line">System.out.println(predicate.test(“Jerry”));</span><br></pre></td></tr></table></figure></li>
<li><p>java.util.function.Consumer<T>，接受参数T，不返回结果，可以实现消息发送</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//打印参数e</span><br><span class="line">Consumer consumer = e -&gt; System.out.println(e);</span><br><span class="line">//打印出Tom</span><br><span class="line">consumer.accept(“Tom”);</span><br></pre></td></tr></table></figure></li>
<li><p>java.util.function.Function&lt;T,R&gt;，接受参数T，返回结果R</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断gender是否是男，可以使用在前端传字符串，后端保存数值</span><br><span class="line">Function&lt;String,Integer&gt; function = gender -&gt; gender.equals(“male”) ? 1:0;</span><br><span class="line">//打印1</span><br><span class="line">function.apply(“male”);</span><br></pre></td></tr></table></figure></li>
<li><p>java.util.function.Supplier，不接受参数，提供T对象的创建工厂</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Supplier supplier = () -&gt; &#123;</span><br><span class="line">return UUID.randomUUID().toString();</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure></li>
<li><p>java.util.function.UnaryOperator<T>，接受参数T，返回类型任然是T</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnaryOperator unaryOperator = username -&gt; username + &quot; 你好&quot;;</span><br><span class="line">System.out.println(unaryOperator.apply(“Tom”));</span><br></pre></td></tr></table></figure></li>
<li><p>java.util.function.BinaryOperator<T>，接受两个参数，返回一个参数，可用于比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//返回参数e1和e2中大的一个</span><br><span class="line">BinaryOperator binaryOperator = (e1 , e2) -&gt; &#123;</span><br><span class="line">return e1 &gt; e2 ? e1 : e2;</span><br><span class="line">&#125;;</span><br><span class="line">//打印13</span><br><span class="line">System.out.println(binaryOperator.apply(12, 13));</span><br></pre></td></tr></table></figure>
<h1 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class App2 &#123;</span><br><span class="line"></span><br><span class="line">    String s1 = &quot;全局变量&quot;;</span><br><span class="line">    public void testInnerClass()&#123;</span><br><span class="line">        String s2 =  &quot;局部变量&quot;;</span><br><span class="line"></span><br><span class="line">        //内部类创建线程</span><br><span class="line">        new Thread( new Runnable() &#123;</span><br><span class="line">            String s3 = &quot;内部变量&quot;;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //访问全局变量，this关键字表示的是当前内部类型的对象</span><br><span class="line">                //System.out.println(this.s1);这样是错的</span><br><span class="line">                System.out.println(s1);</span><br><span class="line"></span><br><span class="line">                //局部变量访问，不能对局部变量进行性数据修改</span><br><span class="line">                System.out.println(s2);</span><br><span class="line">                System.out.println(s3);</span><br><span class="line">                System.out.println(this.s3);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    public void testLambda()&#123;</span><br><span class="line">        String s2 = &quot;局部变量&quot;;</span><br><span class="line">        //Lambda创建线程</span><br><span class="line">        new Thread( () -&gt; &#123;</span><br><span class="line">            String s3 = &quot;内部变量&quot;;</span><br><span class="line">            //this关键字，表示的是所属方法所在类型的对象</span><br><span class="line">            System.out.println(this.s1);</span><br><span class="line">            //不能对局部变量数据s2进行修改</span><br><span class="line">            System.out.println(s2);</span><br><span class="line">            //能对内部变量数据s3进行修改</span><br><span class="line">            System.out.println(s3);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        App2 app2 = new App2();</span><br><span class="line">        app2.testInnerClass();</span><br><span class="line">        app2.testLambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="遍历和排序集合"><a href="#遍历和排序集合" class="headerlink" title="遍历和排序集合"></a>遍历和排序集合</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">    private int width;</span><br><span class="line">    private int length;</span><br><span class="line"></span><br><span class="line">    public Rectangle(int width, int length) &#123;</span><br><span class="line">        this.width = width;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;width=&quot; + width + &quot;,length=&quot; + length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Lambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Rectangle&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Rectangle(6, 2));</span><br><span class="line">        list.add(new Rectangle(2, 3));</span><br><span class="line">        list.add(new Rectangle(3, 4));</span><br><span class="line">        //两种遍历方式</span><br><span class="line">        list.forEach( e -&gt; System.out.println(e));</span><br><span class="line">        //方法引用，指向已经实现的方法</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //倒序排序，因为sort需要一个comparator函数接口，我们可以使用Lambda实现</span><br><span class="line">        list.sort(Comparator.comparing(Rectangle::getLength, (a, b) -&gt; b - a));</span><br><span class="line">        list.sort((a, b) -&gt; b.getLength() - a.getLength());</span><br><span class="line">        </span><br><span class="line">        //删除元素长度等于6的对象</span><br><span class="line">        //removeIf需要Predicate/&lt;T&gt;函数接口，Predicate接受一个参数，返回boolean。</span><br><span class="line">        list.removeIf(e -&gt; e.getLength() == 6);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合简单总结图</title>
    <url>/2021/08/25/Java%E9%9B%86%E5%90%88%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="/images/java%E9%9B%86%E5%90%88.png" alt="java集合"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>一次编辑</title>
    <url>/2021/08/29/%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</url>
    <content><![CDATA[<p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">first = &quot;pale&quot;</span><br><span class="line">second = &quot;ple&quot;</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">first = &quot;pales&quot;</span><br><span class="line">second = &quot;pal&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<p>题解：长度相差1以上，就直接返回false，然后双指针向前移动，遇见不同，俩字符串长度长的或长度一样的指针向前移动，并且结束循环，最后比较剩余的字符串是否一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstLen = first.length();</span><br><span class="line">        <span class="keyword">int</span> secondLen = second.length();</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(firstLen - secondLen) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; firstLen &amp;&amp; j &lt; secondLen)&#123;</span><br><span class="line">            <span class="keyword">char</span> a = first.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> b = second.charAt(j);</span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(firstLen &gt; secondLen)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(firstLen &lt; secondLen)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == firstLen || j == secondLen)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> first.substring(i,firstLen).equals(second.substring(j,secondLen));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/one-away-lcci">https://leetcode-cn.com/problems/one-away-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2021/08/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 target = 22</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \    / \</span><br><span class="line">        7    2  5   1</span><br><span class="line">        </span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>节点总数 &lt;= 10000</p>
<hr>
<p>解题：可以使用深度遍历，到达底部回溯移除叶子节点，在深度遍历其他子树。判断是否路径节点值和等于target，可以每次深度遍历（向下遍历）的时候将target值减去当前节点值，到了叶子节点，如果target等于0，就表示该路径满足条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        dfs(root,target);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        target -= node.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left,target);</span><br><span class="line">        dfs(node.right,target);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入URL到看到页面发生了什么？</title>
    <url>/2021/08/29/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>从输入URL到看到页面发生了什么？</p>
<ul>
<li>DNS解析</li>
<li>发起TCP连接</li>
<li>发送HTTP请求</li>
<li>浏览器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<p>其中每一步的具体过程</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>将网址解析成真正的IP地址，用于浏览器寻找目标服务器，DNS（域名系统）是一个由分层的DNS服务器实现的分布式数据库，一个使得主机能够查询分布式数据库的应用层协议，使用UDP协议，端口53。<br><img src="/images/DNS%E8%A7%A3%E6%9E%90.gif" alt="DNS解析"></p>
<p>递归过程：本地DNS服务器$\Rightarrow$ 根服务器 $\Rightarrow$ 顶级域服务器（TLD）$\Rightarrow$ 权威服务器<br>也可以迭代查询。DNS服务器可以通过DNS缓存将主机名到IP地址的映射保存在本地。</p>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/2021/08/29/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,1,0,1,0,1,100]</span><br><span class="line">输出：100</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 3 * 104</span><br><span class="line">-231 &lt;= nums[i] &lt;= 231 - 1</span><br><span class="line">nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</span><br></pre></td></tr></table></figure>
<p>题解：除元素 m 出现一次外，其余元素都出现三次，那么其余元素第 i 个二进制位之和是3 的倍数，不是 3 的倍数，表示出现一次的数字在该位为 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对int的每一位进行计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 记录第i位和</span></span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                temp += (num&gt;&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否是3的倍数</span></span><br><span class="line">            <span class="keyword">if</span>(temp%<span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/WGki4K">https://leetcode-cn.com/problems/WGki4K</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>位图</title>
    <url>/2021/08/29/%E4%BD%8D%E5%9B%BE/</url>
    <content><![CDATA[<p>在20亿个随机整数中找出某个数m是否存在其中。</p>
<p>基于这个问题，我们可以使用位图来解答。<br>大致思路是将20亿个无序数映射到二进制数组（位图）中去，再去查看数组中是否存在m数，即某位是否为1。</p>
<ul>
<li>所以最重要的是如何映射？</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>在Java中，int占4字节，1字节 = 8位（1 byte = 8 bit）</p>
<p>如果每个数字用int存储，那就是20亿个int，因而占用的空间约为  (2000000000*4/1024/1024/1024)≈7.45G</p>
<p>如果按位存储就不一样了，20亿个数就是20亿位，占用空间约为  (2000000000/8/1024/1024/1024)≈0.233G</p>
<p>可以看出使用二进制数组十分节约空间，提高性能。</p>
<p>一个int在32位，那么 int[0] 可以表示 0-31 ，int[1] 可以表示32-63…int temp[1+ N/32] ,其中N 表示要存储数的最大值，如下图所示。<br><img src="/images/%E4%BD%8D%E5%9B%BE8%E4%BD%8D.png" alt="位图8位"></p>
<p>所以想要表示一个数 M ，就将 int[M/32] 中的第 M%32 位置置为 1 ，具体可以使用异或运算。</p>
<p>如果想将数字 5 放入上面图片表示的数组中去，将1左移 5 位，与原数做异或运算。<br><img src="/images/%E4%BD%8D%E5%9B%BE-%E4%BD%8D%E5%9B%BE%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.png" alt="位图异或"></p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>对无重复元素的数据进行排序，只要将全部元素映射到位图中去，最后遍历位图，如果该位是 1 ，就表示 对应的数存在，已到达排序的目的。</p>
<p>优点：</p>
<ul>
<li>运算效率高，不需要进行比较和移位；</li>
<li>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据不重复。即不可对重复的数据进行排序和查找。</li>
<li>只有当数据比较密集时才有优势</li>
</ul>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>20亿个数去重，可以将所有数据映射到位图中去，留下来的就是不重复的数。</p>
<h2 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h2><p>在大量数据中查找是否存在一个数，可以查看位图中映射位是否为 1 。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><ul>
<li>布隆过滤原理</li>
</ul>
<p>为了节约内存和提高命中率，布隆过滤原理使用多个 hash 函数，求出目标数据的hash值，假如使用了三个hash 函数，计算出三个 hash 值，那么就将位图中这三位置为 1 ，如果想要查看数据库中某条数据是否存在，只需要查看位图中对应三处是否都为 1 ，如果不全为 1，表示该数不存在，全为 1，可能存在。<br><img src="/images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4.png" alt="布隆过滤"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/2021/08/28/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">nums1.length == m + n</span><br><span class="line">nums2.length == n</span><br><span class="line">0 &lt;= m, n &lt;= 200</span><br><span class="line">1 &lt;= m + n &lt;= 200</span><br><span class="line">-109 &lt;= nums1[i], nums2[j] &lt;= 109</span><br></pre></td></tr></table></figure>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题解：使用<strong>逆向双指针</strong>，指针 k 指向大容量数组的末尾，l和r指针从两个数组的尾部向前移动，每次取最大的数赋值给 k 指向的空间，同时 k 向前移动，可能存在左边较大容量的数组遍历完了，然而小容量的数组没有遍历完，所以需要将nums2中的数移到nums1中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=<span class="number">0</span> &amp;&amp; l &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[l] &lt; nums2[r])&#123;</span><br><span class="line">                nums1[k--] = nums2[r--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k--] = nums1[l--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[k--] = nums2[r--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2021/08/30/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1]]</span><br><span class="line">输出：[[1]]</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2],[3,4]]</span><br><span class="line">输出：[[3,1],[4,2]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">matrix.length == n</span><br><span class="line">matrix[i].length == n</span><br><span class="line">1 &lt;= n &lt;= 20</span><br><span class="line">-1000 &lt;= matrix[i][j] &lt;= 1000</span><br></pre></td></tr></table></figure>

<p>题解：先水平翻转，再主对角线翻转，可以得到顺时针旋转 90 度图像。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n-i-<span class="number">1</span>][j];</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>破坏双亲委派模型</title>
    <url>/2021/08/31/%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="/images/pasted-6.png" alt="upload successful"></p>
<h1 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a><strong>破坏双亲委派模型</strong></h1><p>双亲委派主要出现过三次较大规模的“被破坏”的情况。</p>
<ul>
<li>JDK1.2之后，为避免<code>loadClass()</code>被子类覆盖的可能，建议用户重写<code>findClass()</code>方法；</li>
<li>JNDI作为java的标准服务，需要调用启动类加载器不认识的外部接口（其他厂商实现的）；</li>
<li>IBM公司OSGI实现模块化热部署的关键是自定义类加载器机制，更换Bundle（程序模块）时，类加载器也会被换掉，然而类加载机制与双亲委派机制不同。</li>
</ul>
<h2 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h2><ul>
<li>问题：类加载器的概念和抽象类的概念在java的第一个版本中就出现了，但是在jdk1.2及以前并没有双亲委派机制，所以当java设计者想要引入双亲委派机制时就不得不做出一点妥协，包含兼容用户自己自己的代码（用户自定义类加载器的代码），无法再以技术手段避免loadClass()被子类覆盖的可能性。</li>
<li>解决：java设计者想出的办法是在java.lang.ClassLoader()中添加一个新的protected方法findClass()，并引导用户编写类加载逻辑时尽可能去重=写这个方法，而不是在loadClass中编写代码。</li>
</ul>
<p>loadClass()：先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClassQ方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出 ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Classc&lt;?&gt; 1oadClass(String name，<span class="keyword">boolean</span> resolve) <span class="keyword">throw</span></span><br><span class="line">classNotFoundException&#123;</span><br><span class="line">	<span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">    Class c = findLoadedclass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">				c = parent.loadClass(name,<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c = findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">		<span class="comment">//如果父类加载器抛出classNotFoundException</span></span><br><span class="line">		<span class="comment">//说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="keyword">null</span>）&#123;</span><br><span class="line">		<span class="comment">//在父类加载器无法加载时</span></span><br><span class="line">		<span class="comment">//再调用本身的findclass方法来进行类加载c = findclass (name);</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><ul>
<li>问题：JNDI服务是java的标准服务，其代码是由启动类加载器加载的，属于非常基础的类型，然而JNDI的目的就会为了查找资源并对其集中管理，需要调用由其他应用厂商实现并部署 JDNI 服务提供者接口代码，所以会出现类加载器不认识和加载这些代码。</li>
<li>解决：引入线程上下文类加载器，JNDI使用这个类加载器去加载所需的SPI服务代码，这是一种父类加载器请求子类加载器完成类加载的行为，打破了双亲委派模型的层次结构来逆向使用类加载器，即违背了双亲委派模型的一般原则。</li>
</ul>
<p><a href="https://www.jianshu.com/p/3a3edbcd8f24">什么是SPI？</a></p>
<h2 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h2><p><img src="/images/OSGi_Alliance_Logo.png" alt="OSGi_Alliance_Logo.png"></p>
<ul>
<li>问题：用户对程序动态性的追求导致的，“动态性”指的是：代码热替换、模块化热部署。这种情况下，例如OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每个程序模块（Bundle）都有自己的类加载器，更换一个Bundle就得替换类加载器以实现代码的热替换。</li>
<li>OSGi环境下，类加载器不再使用双亲委派机制，而是使用更加复杂的网状结构。OSGi类加载搜索过程如下，</li>
</ul>
<blockquote>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载。         // 符合双亲委派机制</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。// 符合双亲委派机制</li>
<li>否则，将Import列表中的类，委派给Export这个类的 Bundle的类加载器加载。// 不符合，下同</li>
<li>否则,查找当前Bundle的 ClassPath，使用自己的类加载器加载。</li>
<li>否则,查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找 Dynamic Import列表的 Bundle，委派给对应 Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>管程</title>
    <url>/2021/08/28/%E7%AE%A1%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="管程的定义"><a href="#管程的定义" class="headerlink" title="管程的定义"></a>管程的定义</h2><ul>
<li>系统中的各种硬件资源和软件资源均可用数据结构抽象地描述其资源特性，即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。因此，可以利用共享数据结构抽象地表示系统中的共享资源，并且将对该共享数据结构实施的特定操作定义为一组过程。进程对共享资源的申请、释放和其它操作必须通过这组过程，间接地对共享数据结构实现操作。对于请求访问共享资源的诸多并发进程，可以根据资源的情况接受或阻塞，确保每次仅有一个进程进入管程，执行这组过程，使用共享资源，达到对共享资源所有访问的统一管理,有效地实现进程互斥。</li>
<li>代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，我们称之为管程，管程被请求和释放资源的进程所调用。<blockquote>
<p>Hansan为管程所下的定义是：“一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。”</p>
</blockquote>
</li>
</ul>
<h2 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h2><p>由上述的定义可知，管程由四部分组成：</p>
<ol>
<li>管程的名称;</li>
<li>局部于管程的共享数据结构说明;</li>
<li>对该数据结构进行操作的一组过程;</li>
<li>对局部于管程的共享数据设置初始值的语句。</li>
</ol>
<p><img src="/images/%E7%AE%A1%E7%A8%8B.gif" alt="管程结构"></p>
<p>实际上，管程中包含了面向对象的思想，它将表征共享资源的数据结构及其对数据结构操作的一组过程，包括同步机制，都集中并封装在一个对象内部，隐藏了实现细节。封装于管程内部的数据结构仅能被封装于管程内部的过程所访问，任何管程外的过程都不能访问它;反之，封装于管程内部的过程也仅能访问管程内的数据结构。所有进程要访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，执行管程内的过程，从而实现了进程互斥。</p>
<h2 id="管程的特性"><a href="#管程的特性" class="headerlink" title="管程的特性"></a>管程的特性</h2><p>管程是一种程序设计语言的结构成分，它和信号量有同等的表达能力，从语言的角度看，管程主要有以下特性</p>
<ul>
<li>模块化，即管程是一个基本程序单位，可以单独编译;</li>
<li>抽象数据类型，指管程中不仅有数据，而且有对数据的操作；</li>
<li>信息屏蔽，指管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，供管程外的进程调用，而管程中的数据结构以及过程(函数)的具体实现外部不可见。</li>
</ul>
<h2 id="管程和进程的比较"><a href="#管程和进程的比较" class="headerlink" title="管程和进程的比较"></a>管程和进程的比较</h2><ol>
<li>虽然二者都定义了数据结构，但进程定义的是私有数据结构PCB，管程定义的是公共数据结构，如消息队列等;</li>
<li>二者都存在对各自数据结构上的操作，但进程是由顺序程序执行有关操作，而管程主要是进行同步操作和初始化操作；</li>
<li>设置进程的目的在于实现系统的并发性，而管程的设置则是解决共享资源的互斥使用问题;</li>
<li>进程通过调用管程中的过程对共享数据结构实行操作，该过程就如通常的子程序一样被调用，因而管程为被动工作方式，进程则为主动工作方式;</li>
<li>进程之间能并发执行，而管程则不能与其调用者并发;</li>
<li>进程具有动态性，由“创建”而诞生，由“撤消”而消亡，而管程则是操作系统中的一个资源管理模块，供进程调用。</li>
</ol>
<h2 id="为什么使用管程？"><a href="#为什么使用管程？" class="headerlink" title="为什么使用管程？"></a>为什么使用管程？</h2><p>信号量机制是一种进程同步机制，但每个要访问临界资源的进程都必须自备同步操作wait(S)和signal(S)。这样大量同步操作分散到各个进程中，可能会导致系统管理问题和死锁，在解决上述问题的过程中，便产生了新的进程同步工具——管程。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>管程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程的比较</title>
    <url>/2021/08/27/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>由于线程具有许多传统进程所具有的特征，所以又称之为轻型进程(Light-WeightProcess)或进程元，相应地，把传统进程称为重型进程(Heavy-Weight Process)。它相当于只有一个线程的任务。下面从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。</p>
<ul>
<li><p>调度的基本单位</p>
<blockquote>
<p>在传统的OS 中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次被调度时，都需要进行上下文切换，开销较大。而在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换。</p>
</blockquote>
</li>
<li><p>并发性</p>
<blockquote>
<p>在引入线程的OS 中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，甚至还允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。这使得OS具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。例如，在文字处理器中可以设置三个线程:第一个线程用于显示文字和图形，第二个线程从键盘读入数据，第三个线程在后台进行拼写和语法检查。又如，在网页浏览器中，可以设置一个线程来显示图像或文本，再设置一个线程用于从网络中接收数据。<br>此外，有的应用程序需要执行多个相似的任务。例如，一个网络服务器经常会接到许多客户的请求，如果仍采用传统的单线程的进程来执行该任务，则每次只能为一个客户服务。但如果在一个进程中可以设置多个线程，将其中的一个专用于监听客户的请求，则每当有一个客户请求时，便立即创建一个线程来处理该客户的请求。</p>
</blockquote>
</li>
<li><p>拥有资源</p>
<blockquote>
<p>进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源。比如，在每个线程中都应具有一个用于控制线程运行的线程控制块TCB、用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。<br>线程除了拥有自己的少量资源外，还允许多个线程共享该进程所拥有的资源，这首先表现在：属于同一进程的所有线程都具有相同的地址空间，这意味着，线程可以访问该地址空间中的每一个虚地址；此外，还可以访问进程所拥有的资源，如已打开的文件、定时器、信号量机构等的内存空间和它所申请到的IO设备等。</p>
</blockquote>
</li>
<li><p>独立性</p>
<blockquote>
<p>在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是因为，为防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。由一个线程打开的文件可以供其它线程读、写。</p>
</blockquote>
</li>
<li><p>系统开销</p>
<blockquote>
<p>在创建或撤消进程时，系统都要为之分配和回收进程控制块、分配或回收其它资源，如内存空间和I/O设备等。OS为此所付出的开销，明显大于线程创建或撤消时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换远低于进程的。例如，在Solaris 2 OS中，线程的创建要比进程的创建快30倍，而线程上下文的切换要比进程上下文的切换快5倍。此外，由于一个进程中的多个线程具有相同的地址空间，线程之间的同步和通信也比进程的简单。因此，在一些OS中，线程的切换、同步和通信都无需操作系统内核的干预。</p>
</blockquote>
</li>
<li><p>支持多处理机系统</p>
<blockquote>
<p>在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。因此，现代多处理机OS 都无一例外地引入了多线程。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度算法</title>
    <url>/2021/08/28/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="进程调方式"><a href="#进程调方式" class="headerlink" title="进程调方式"></a>进程调方式</h1><ul>
<li><p>非抢占式</p>
<ul>
<li>进程分配到处理机时，就会一直执行下去，不会被其他进程抢占，直到该进程完成或被阻塞。</li>
</ul>
</li>
<li><p>抢占式</p>
<ul>
<li><p>允许调度程序根据某种原则，去暂停某个正在执行的进程，将以分配的处理机重新分配给另一进程。这样可以防止一个长进程长时间地占用处理机。</p>
<blockquote>
<p> 主要原则： </p>
<ol>
<li>优先权原则，优先级高的进程可以占用当前进程；</li>
<li>短进程优先原则，短进程可以抢占当前长进程的处理机；</li>
<li>时间片原则，当前进程的时间片用完，执行其他进程。 </li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="轮转调度算法-RR"><a href="#轮转调度算法-RR" class="headerlink" title="轮转调度算法(RR)"></a>轮转调度算法(RR)</h1><ol>
<li>原理</li>
</ol>
<ul>
<li>在轮转(RR)法中，系统根据 FCFS（先来先服务）策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30 ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程(或新到达的紧迫进程)。由此，可保证就绪队列中的所有进程在一个确定的时间段内，都能够获得一次CPU执行。</li>
</ul>
<ol start="2">
<li>时间片大小</li>
</ol>
<ul>
<li>时间片小，意味着频繁执行进程调度和进程的上下文的切换，增加系统的开销；时间片长，RR算法退化成FCFS算法，无法满足短作业和交互式用户的需求。</li>
<li>取大多数进程能在一个时间片内完成所对应的时间。</li>
</ul>
<h1 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h1><ul>
<li>将处理机分配给就绪队列中优先级最高的进程。</li>
<li>优先级类型<ul>
<li>静态优先级，创建进程时确定，运行过程中不变；<br> - 动态优先级，创建进程时先赋予一个优先级，然后其值随进程的推进或等待时间的增加而改变，如等待时间增长优先级提高；</li>
</ul>
</li>
</ul>
<h1 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h1><ul>
<li>上述调度算法，系统中仅设置了一个进程的就绪队列，无法满足系统中不同用户对进程调度策略的不同要求。</li>
<li>该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。多队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。</li>
</ul>
<h1 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h1><ul>
<li>上述算法中，如果未指明进程长度，短进程优先和基于进程长度的抢占式调度算法都将无法使用。多级反馈队列调度算法不必事先知道进程长度，是目前公认的一种比较好的进程调度算法。</li>
</ul>
<ol>
<li>调度机制<ul>
<li>设置 N 个就绪队列，优先级依次降低，时间片长度逐个增加一倍；</li>
<li>每个队列采用 FCFS 算法，当新进程进入内存后，先将其放至第一个就绪队列末尾，轮到该进程执行时，若进程在时间片内完成，则撤离系统，否则放入下一个就绪队列末尾；第 N 个队列采用 RR 调度方式；</li>
<li>按队列优先级调度：当第1~(i-1) 就绪队列均为空时，系统才会调度第 i 队列；当优先级更高的队列有新进程时，把当前执行的进程放入其所在队列末尾，立即去调用优先级更高的进程。</li>
</ul>
</li>
</ol>
<p><img src="/images/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="多级反馈队列调度算法"><br>2. 性能</p>
<ul>
<li>终端型用户。由于终端型用户提交的作业多属于交互型作业，通常较小，系统要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意。</li>
<li>短批处理作业用户。对于这类作业，如果可在第一队列中执行完成，便获得与终端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。</li>
<li>长批处理作业用户。对于长作业,它将依次在第1,2,…，n个队列中运行，然后再按轮转方式运行,用户不必担心其作业长期得不到处理。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
</search>
